# Programmers.Level3_Java_Budget

## 1. 문제설명
input으로 지방에서 국가에 원하는 요청 예산액 int[]과 국가가 가지고있는 총 예산 M을 받는다. 가능한 한 최대의 예산을 return하며 최대의 예산은 모든 요청을 배정할 수 있는 경우 요청한 금액을 그대로 배정하며, 모든 요청이 배정될 수 없는 경우 특정한 정수 상한액을 계산하여 그 이상 요청한 지방에 대해선 상한액을 배정한다.

## 2. 풀이
0원부터 M원 사이에서 국가의 예산 상한선을 골라서 적용해본다. 테스트할 예산액은 이분검색으로 정하며 로그만큼의 복잡도를 가진다. 테스트할 값 ```mid=(left+right)/2```에 대해 지급되는 총 예산액을 계산하며 M과 비교하여 지급가능하다면(total <=M) ```left=mid```, 지급 불가능하다면(total > M) ```right=mid```이후 테스트를 재 진행한다. mid값이 이전과 같다면 가장 유망한 후보 예산액이 mid로 찾아진 것이므로 이를 return하여 해결하였다.

## 3. 어려웠던 점
* 효율성테스트
  * 시간
  
     초기 이분검색은 input으로 들어온 budgets에 대하여 M/budgets.length를 target으로 하여 진행하였다. target보다 작은 budget중 가장 큰 budget의 index를 찾은 후 그 budget[index]부터 나올 수 있는 모든 예산액을 검사해보며 최대 상한 예산액을 찾으려고 하였으나, input으로 들어오는 예산액의 범위가 너무 커 binarySearch를 마친후 모든 예산액에대해 검사를 진행하는것보다 예산액을 기준으로 이분검색을 끝까지 진행하는것이 효율적임을 알 수 있었다.
     
  * 효율성 테스트
  
     현재 테스트하는 상한예산액으로 결정하였을때의 총 예산액과 M을 비교하는 과정에서 국가가 가질수 있는 총 예산은 10억이며 각 지방에서 요구하는 예산의 합은 그 값을 넘을 수도 있다. int형으로 totalBudget를 계산하는것은 오버플로우의 위험이 있으므로 int형(-2^31-1 ~ 2^31)대신 long형(-2^63-1 ~ 2^63)으로 두는것이 맞는 선택이다.
